#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "typer>=0.12.0",
#     "rich>=13.0.0",
#     "python-dotenv>=1.0.0",
# ]
# ///

"""
Secret Manager - A developer tool for managing secrets with Bitwarden, Skate, and age encryption.
"""

import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional

import typer
from rich import print
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt

app = typer.Typer(help="Secret Manager - Manage secrets with Bitwarden, Skate, and age encryption")
console = Console()

# Constants
SSH_KEY_NAME = "ssh.key.ed25519.main"
LOCAL_SSH_KEY_PATH = Path.home() / ".ssh" / "id_ed25519"
LOCAL_SSH_PUB_PATH = Path.home() / ".ssh" / "id_ed25519.pub"
AGE_KEY_PATH = Path.home() / ".config" / "secretman" / "age.key"
SESSION_FILE = Path.home() / ".config" / "secretman" / "session"


class SecretManager:
    def __init__(self):
        self.session = None
        self.ssh_key_path = None
        self._ensure_dirs()

    def _ensure_dirs(self):
        """Ensure necessary directories exist."""
        config_dir = Path.home() / ".config" / "secretman"
        config_dir.mkdir(parents=True, exist_ok=True, mode=0o700)

        ssh_dir = Path.home() / ".ssh"
        ssh_dir.mkdir(exist_ok=True, mode=0o700)

    def _run_command(self, command: list, capture_output: bool = True, check: bool = True) -> subprocess.CompletedProcess:
        """Run a command and return the result."""
        try:
            result = subprocess.run(
                command,
                capture_output=capture_output,
                text=True,
                check=check
            )
            return result
        except subprocess.CalledProcessError as e:
            console.print(f"[red]Command failed:[/red] {' '.join(command)}")
            console.print(f"[red]Error:[/red] {e.stderr}")
            raise

    def _check_bitwarden(self) -> bool:
        """Check if Bitwarden CLI is installed."""
        try:
            self._run_command(["bw", "--version"])
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _check_skate(self) -> bool:
        """Check if Skate is installed."""
        try:
            self._run_command(["skate", "--version"])
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _check_age(self) -> bool:
        """Check if age is installed."""
        try:
            self._run_command(["age", "--version"])
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def login_bitwarden(self, email: Optional[str] = None) -> bool:
        """Login to Bitwarden and store session."""
        if not email:
            email = Prompt.ask("Enter your Bitwarden email")

        # Check if already logged in
        try:
            status = self._run_command(["bw", "status"], check=False)
            status_data = json.loads(status.stdout)

            if status_data.get("status") == "unlocked":
                console.print("[green]Already logged in and unlocked[/green]")
                self.session = os.environ.get("BW_SESSION")
                if self.session:
                    return True
        except:
            pass

        # Login
        console.print(f"[blue]Logging into Bitwarden as {email}...[/blue]")
        try:
            login_result = self._run_command(["bw", "login", email], capture_output=False)
        except subprocess.CalledProcessError:
            console.print("[yellow]Already logged in, unlocking...[/yellow]")

        # Unlock
        password = Prompt.ask("Enter your Bitwarden master password", password=True)
        unlock_result = self._run_command(["bw", "unlock", "--raw"], input=password)

        if unlock_result.stdout:
            self.session = unlock_result.stdout.strip()
            # Store session for reuse within this process
            os.environ["BW_SESSION"] = self.session

            # Optionally save session to file (encrypted later)
            SESSION_FILE.write_text(self.session)
            SESSION_FILE.chmod(0o600)

            console.print("[green]Successfully logged into Bitwarden[/green]")
            return True

        return False

    def download_ssh_key(self) -> Path:
        """Download SSH key from Bitwarden."""
        if not self.session:
            raise RuntimeError("Not logged into Bitwarden")

        console.print(f"[blue]Searching for SSH key '{SSH_KEY_NAME}'...[/blue]")

        # Search for the SSH key
        search_result = self._run_command(
            ["bw", "list", "items", "--search", SSH_KEY_NAME, "--session", self.session]
        )

        items = json.loads(search_result.stdout)
        if not items:
            console.print(f"[yellow]SSH key '{SSH_KEY_NAME}' not found in Bitwarden[/yellow]")
            return self._create_local_ssh_key()

        # Get the first matching item
        item = items[0]
        item_id = item["id"]

        # Get the full item details
        item_result = self._run_command(
            ["bw", "get", "item", item_id, "--session", self.session]
        )

        item_data = json.loads(item_result.stdout)

        # Extract SSH key from notes or custom fields
        ssh_key_content = None

        # Check notes first
        if item_data.get("notes"):
            ssh_key_content = item_data["notes"]

        # Check custom fields
        if not ssh_key_content and item_data.get("fields"):
            for field in item_data["fields"]:
                if field.get("name") == "private_key":
                    ssh_key_content = field.get("value")
                    break

        if not ssh_key_content:
            console.print("[yellow]SSH key content not found in item[/yellow]")
            return self._create_local_ssh_key()

        # Save SSH key
        LOCAL_SSH_KEY_PATH.write_text(ssh_key_content)
        LOCAL_SSH_KEY_PATH.chmod(0o600)

        # Generate public key
        self._run_command(
            ["ssh-keygen", "-y", "-f", str(LOCAL_SSH_KEY_PATH)],
            capture_output=True
        )

        console.print(f"[green]SSH key downloaded to {LOCAL_SSH_KEY_PATH}[/green]")
        self.ssh_key_path = LOCAL_SSH_KEY_PATH
        return LOCAL_SSH_KEY_PATH

    def _create_local_ssh_key(self) -> Path:
        """Create a local SSH key if not found in Bitwarden."""
        if LOCAL_SSH_KEY_PATH.exists():
            console.print(f"[yellow]Using existing SSH key at {LOCAL_SSH_KEY_PATH}[/yellow]")
            self.ssh_key_path = LOCAL_SSH_KEY_PATH
            return LOCAL_SSH_KEY_PATH

        console.print("[blue]Creating new SSH key...[/blue]")

        # Generate new SSH key
        self._run_command([
            "ssh-keygen",
            "-t", "ed25519",
            "-f", str(LOCAL_SSH_KEY_PATH),
            "-N", "",  # No passphrase
            "-C", "secretman@local"
        ])

        console.print(f"[green]Created new SSH key at {LOCAL_SSH_KEY_PATH}[/green]")
        self.ssh_key_path = LOCAL_SSH_KEY_PATH
        return LOCAL_SSH_KEY_PATH

    def setup_ssh_agent(self) -> bool:
        """Setup SSH agent with the key."""
        if not self.ssh_key_path:
            raise RuntimeError("SSH key not available")

        # Check if ssh-agent is running
        if not os.environ.get("SSH_AUTH_SOCK"):
            console.print("[blue]Starting SSH agent...[/blue]")
            agent_result = self._run_command(["ssh-agent", "-s"])

            # Parse and set environment variables
            for line in agent_result.stdout.split('\n'):
                if line.startswith("SSH_AUTH_SOCK="):
                    sock = line.split('=')[1].split(';')[0]
                    os.environ["SSH_AUTH_SOCK"] = sock
                elif line.startswith("SSH_AGENT_PID="):
                    pid = line.split('=')[1].split(';')[0]
                    os.environ["SSH_AGENT_PID"] = pid

        # Add key to agent
        self._run_command(["ssh-add", str(self.ssh_key_path)])
        console.print("[green]SSH key added to agent[/green]")
        return True

    def setup_age_key(self) -> bool:
        """Convert SSH key to age key."""
        if not self.ssh_key_path:
            raise RuntimeError("SSH key not available")

        # Convert SSH key to age key
        result = self._run_command([
            "ssh-to-age",
            "-private-key",
            "-i", str(self.ssh_key_path)
        ], check=False)

        if result.returncode != 0:
            # Try using age-keygen instead
            console.print("[yellow]ssh-to-age not found, using age-keygen[/yellow]")

            # Generate age key
            age_result = self._run_command(["age-keygen"])
            age_key = age_result.stdout.strip()

            AGE_KEY_PATH.parent.mkdir(parents=True, exist_ok=True)
            AGE_KEY_PATH.write_text(age_key)
            AGE_KEY_PATH.chmod(0o600)
        else:
            age_key = result.stdout.strip()
            AGE_KEY_PATH.parent.mkdir(parents=True, exist_ok=True)
            AGE_KEY_PATH.write_text(age_key)
            AGE_KEY_PATH.chmod(0o600)

        console.print(f"[green]Age key setup at {AGE_KEY_PATH}[/green]")
        return True

    def encrypt_value(self, value: str) -> str:
        """Encrypt a value using age."""
        if not AGE_KEY_PATH.exists():
            raise RuntimeError("Age key not setup")

        # Get recipient from age key file
        with open(AGE_KEY_PATH) as f:
            for line in f:
                if line.startswith("# public key:"):
                    recipient = line.split(":")[1].strip()
                    break
            else:
                raise RuntimeError("Could not find public key in age key file")

        # Encrypt
        result = self._run_command(
            ["age", "-r", recipient, "-a"],
            input=value
        )

        return result.stdout.strip()

    def decrypt_value(self, encrypted: str) -> str:
        """Decrypt a value using age."""
        if not AGE_KEY_PATH.exists():
            raise RuntimeError("Age key not setup")

        # Decrypt
        result = self._run_command(
            ["age", "-d", "-i", str(AGE_KEY_PATH)],
            input=encrypted
        )

        return result.stdout.strip()

    def set_secret(self, key: str, value: str, encrypt: bool = True):
        """Set a secret in skate."""
        if encrypt:
            value = self.encrypt_value(value)
            key = f"encrypted:{key}"

        self._run_command(["skate", "set", key, value])
        console.print(f"[green]Secret '{key}' saved[/green]")

    def get_secret(self, key: str, decrypt: bool = True) -> Optional[str]:
        """Get a secret from skate."""
        if decrypt:
            key = f"encrypted:{key}"

        result = self._run_command(["skate", "get", key], check=False)

        if result.returncode != 0:
            return None

        value = result.stdout.strip()

        if decrypt and value:
            value = self.decrypt_value(value)

        return value

    def list_secrets(self):
        """List all secrets in skate."""
        result = self._run_command(["skate", "list"])

        secrets = []
        for line in result.stdout.strip().split('\n'):
            if line:
                parts = line.split(maxsplit=1)
                if parts:
                    key = parts[0]
                    if key.startswith("encrypted:"):
                        key = key[10:]  # Remove 'encrypted:' prefix
                    secrets.append(key)

        return secrets


# Global instance
manager = SecretManager()


@app.command()
def init(email: Optional[str] = typer.Option(None, help="Bitwarden email")):
    """Initialize the secret manager."""
    console.print(Panel.fit("🔐 Secret Manager Initialization", style="bold blue"))

    # Check dependencies
    checks = [
        ("Bitwarden CLI", manager._check_bitwarden()),
        ("Skate", manager._check_skate()),
        ("age", manager._check_age()),
    ]

    for name, installed in checks:
        if installed:
            console.print(f"✅ {name} is installed")
        else:
            console.print(f"❌ {name} is not installed")
            console.print(f"   Please install {name} first")
            raise typer.Exit(1)

    # Login to Bitwarden
    if not manager.login_bitwarden(email):
        console.print("[red]Failed to login to Bitwarden[/red]")
        raise typer.Exit(1)

    # Download SSH key
    manager.download_ssh_key()

    # Setup SSH agent
    manager.setup_ssh_agent()

    # Setup age key
    manager.setup_age_key()

    console.print("[bold green]✨ Secret Manager initialized successfully![/bold green]")


@app.command()
def set(
    key: str = typer.Argument(help="Secret key"),
    value: Optional[str] = typer.Argument(None, help="Secret value (will prompt if not provided)"),
    no_encrypt: bool = typer.Option(False, "--no-encrypt", help="Don't encrypt the value")
):
    """Set a secret."""
    if SESSION_FILE.exists():
        manager.session = SESSION_FILE.read_text().strip()
        os.environ["BW_SESSION"] = manager.session

    if not value:
        value = Prompt.ask(f"Enter value for '{key}'", password=True)

    manager.set_secret(key, value, encrypt=not no_encrypt)


@app.command()
def get(
    key: str = typer.Argument(help="Secret key"),
    no_decrypt: bool = typer.Option(False, "--no-decrypt", help="Don't decrypt the value")
):
    """Get a secret."""
    if SESSION_FILE.exists():
        manager.session = SESSION_FILE.read_text().strip()
        os.environ["BW_SESSION"] = manager.session

    value = manager.get_secret(key, decrypt=not no_decrypt)

    if value is None:
        console.print(f"[red]Secret '{key}' not found[/red]")
        raise typer.Exit(1)

    console.print(value)


@app.command()
def list():
    """List all secrets."""
    if SESSION_FILE.exists():
        manager.session = SESSION_FILE.read_text().strip()
        os.environ["BW_SESSION"] = manager.session

    secrets = manager.list_secrets()

    if not secrets:
        console.print("[yellow]No secrets found[/yellow]")
        return

    console.print(Panel.fit("📋 Stored Secrets", style="bold blue"))
    for secret in secrets:
        console.print(f"  • {secret}")


@app.command()
def delete(
    key: str = typer.Argument(help="Secret key"),
    force: bool = typer.Option(False, "--force", "-f", help="Skip confirmation")
):
    """Delete a secret."""
    if not force:
        confirm = Prompt.ask(f"Are you sure you want to delete '{key}'? [y/N]")
        if confirm.lower() != 'y':
            console.print("[yellow]Cancelled[/yellow]")
            raise typer.Exit(0)

    encrypted_key = f"encrypted:{key}"
    result = manager._run_command(["skate", "delete", encrypted_key], check=False)

    if result.returncode == 0:
        console.print(f"[green]Secret '{key}' deleted[/green]")
    else:
        console.print(f"[red]Failed to delete secret '{key}'[/red]")
        raise typer.Exit(1)


@app.command()
def logout():
    """Logout and clear session."""
    if SESSION_FILE.exists():
        SESSION_FILE.unlink()

    if os.environ.get("BW_SESSION"):
        del os.environ["BW_SESSION"]

    # Lock Bitwarden
    manager._run_command(["bw", "lock"], check=False)

    console.print("[green]Logged out successfully[/green]")


if __name__ == "__main__":
    app()