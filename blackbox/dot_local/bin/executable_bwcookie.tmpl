#!/bin/sh
'''exec' uv run --script "$0" "$@"
'''
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "typer>=0.12.0",
#     "loguru>=0.7.2",
#     "rich>=13.7.0",
# ]
# ///

"""
bwcookie - A developer tool for managing secrets with Bitwarden, Skate, and age encryption.

This tool combines:
- Bitwarden CLI for secret storage
- Charmbracelet Skate for local caching
- age encryption for secure local storage
- SSH agent integration for key management
"""

import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional, Dict, Any

import typer
from loguru import logger
from rich.console import Console
from rich.spinner import Spinner

app = typer.Typer(help="Manage secrets with Bitwarden and local encrypted cache")
console = Console()

# Configure logging
logger.remove()
logger.add(sys.stderr, level="INFO", format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <level>{message}</level>")

class BWCookie:
    def __init__(self):
        self.session_key: Optional[str] = None
        self.ssh_key_path = Path.home() / ".ssh" / "id_ed25519"
        self.ensure_ssh_key()

    def ensure_ssh_key(self):
        """Ensure SSH key exists or create one."""
        if not self.ssh_key_path.exists():
            logger.info("Creating SSH key at ~/.ssh/id_ed25519")
            self.ssh_key_path.parent.mkdir(mode=0o700, exist_ok=True)
            subprocess.run([
                "ssh-keygen", "-t", "ed25519", "-f", str(self.ssh_key_path),
                "-N", "", "-C", "bwcookie@local"
            ], check=True)
            self.ssh_key_path.chmod(0o600)
            (self.ssh_key_path.with_suffix(".pub")).chmod(0o644)

    def ensure_age_key(self):
        """Ensure age key exists or create one."""
        self.age_key_path.parent.mkdir(mode=0o700, exist_ok=True)

        if not self.age_key_path.exists():
            logger.info("Generating age key")
            subprocess.run([
                "age-keygen", "-o", str(self.age_key_path)
            ], check=True)
            self.age_key_path.chmod(0o600)

    def get_age_recipient(self) -> str:
        """Get the age recipient (public key) from the age key."""
        age_key_content = self.age_key_path.read_text().strip()
        for line in age_key_content.split('\n'):
            if line.startswith("# public key:"):
                return line.split(":", 1)[1].strip()

        # Fallback: derive public key
        logger.warning("Could not find public key in age key file, deriving it")
        result = subprocess.run([
            "age-keygen", "-y"
        ], input=age_key_content, capture_output=True, text=True, check=True)
        return result.stdout.strip()

    def login(self) -> bool:
        """Login to Bitwarden and store session key in memory."""
        try:
            # Check if already logged in
            result = subprocess.run(["bw", "status"], capture_output=True, text=True)
            status = json.loads(result.stdout)

            current_status = status.get("status")
            logger.info(f"Current Bitwarden status: {current_status}")

            if current_status == "unlocked":
                logger.info("Already logged in and unlocked")
                # Get session key from environment or prompt
                self.session_key = os.environ.get("BW_SESSION")
                if not self.session_key:
                    logger.error("BW_SESSION not found in environment")
                    return False
                return True
            elif current_status == "locked":
                # Vault is locked, just need to unlock
                logger.info("Vault is locked, unlocking...")
                password = typer.prompt("Bitwarden password", hide_input=True)
                result = subprocess.run(
                    ["bw", "unlock", "--raw"],
                    input=password,
                    capture_output=True,
                    text=True,
                    check=True
                )
                self.session_key = result.stdout.strip()
                logger.success("Successfully unlocked Bitwarden vault")

                # Try to download main SSH key
                self.download_main_ssh_key()
                return True
            elif current_status == "unauthenticated":
                # Not logged in at all, need full login
                logger.info("Not authenticated, performing full login...")
                email = typer.prompt("Bitwarden email")

                # First login
                subprocess.run(["bw", "login", email], check=True)

                # Then unlock
                password = typer.prompt("Bitwarden password", hide_input=True)
                result = subprocess.run(
                    ["bw", "unlock", "--raw"],
                    input=password,
                    capture_output=True,
                    text=True,
                    check=True
                )
                self.session_key = result.stdout.strip()
                logger.success("Successfully logged in to Bitwarden")

                # Try to download main SSH key
                self.download_main_ssh_key()
                return True
            else:
                logger.error(f"Unknown Bitwarden status: {current_status}")
                return False

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to login to Bitwarden: {e}")
            if e.stderr:
                logger.error(f"Error details: {e.stderr}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse Bitwarden response: {e}")
            return False

    def unlock_vault(self) -> Optional[str]:
        """Unlock Bitwarden vault and return session key."""
        try:
            password = typer.prompt("Bitwarden password", hide_input=True)
            result = subprocess.run(
                ["bw", "unlock", "--raw"],
                input=password,
                capture_output=True,
                text=True,
                check=True
            )
            session_key = result.stdout.strip()
            logger.success("Successfully unlocked Bitwarden vault")
            return session_key
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to unlock vault: {e}")
            if e.stderr:
                logger.error(f"Error details: {e.stderr}")
            return None

    def download_main_ssh_key(self):
        """Download main SSH key from Bitwarden if available."""
        try:
            result = subprocess.run([
                "bw", "get", "item", "ssh.key.ed25519.main",
                "--session", self.session_key
            ], capture_output=True, text=True)

            if result.returncode == 0:
                item = json.loads(result.stdout)
                if "notes" in item and item["notes"]:
                    logger.info("Found main SSH key in Bitwarden, updating local key")
                    backup_path = self.ssh_key_path.with_suffix(".backup")
                    if self.ssh_key_path.exists():
                        self.ssh_key_path.rename(backup_path)

                    self.ssh_key_path.write_text(item["notes"])
                    self.ssh_key_path.chmod(0o600)

                    logger.success("Updated SSH key from Bitwarden")
        except Exception as e:
            logger.debug(f"Could not download main SSH key: {e}")

    def encrypt_value(self, value: str) -> str:
        """Encrypt a value using age with SSH key."""
        # Get SSH public key
        ssh_pub_path = self.ssh_key_path.with_suffix(".pub")
        if not ssh_pub_path.exists():
            # Generate public key from private
            subprocess.run([
                "ssh-keygen", "-y", "-f", str(self.ssh_key_path)
            ], stdout=ssh_pub_path.open('w'), check=True)

        # Read the public key content
        ssh_pub_key = ssh_pub_path.read_text().strip()

        # Encrypt using SSH public key as recipient
        result = subprocess.run([
            "age", "-r", ssh_pub_key, "-a"
        ], input=value.encode(), capture_output=True, check=True)

        return result.stdout.decode('utf-8').strip()

    def decrypt_value(self, encrypted: str) -> str:
        """Decrypt a value using age with SSH key."""
        result = subprocess.run([
            "age", "-d", "-i", str(self.ssh_key_path)
        ], input=encrypted.encode(), capture_output=True, check=True)

        return result.stdout.decode('utf-8')

    def get_from_skate(self, key: str) -> Optional[str]:
        """Get encrypted value from skate and decrypt it."""
        try:
            result = subprocess.run([
                "skate", "get", f"bwcookie:{key}"
            ], capture_output=True, text=True)

            if result.returncode == 0 and result.stdout.strip():
                encrypted = result.stdout.strip()
                return self.decrypt_value(encrypted)

            return None
        except Exception as e:
            logger.debug(f"Failed to get from skate: {e}")
            return None

    def set_in_skate(self, key: str, value: str):
        """Encrypt value and store in skate."""
        try:
            encrypted = self.encrypt_value(value)
            # Use stdin to avoid issues with special characters
            subprocess.run([
                "skate", "set", f"bwcookie:{key}"
            ], input=encrypted.encode(), check=True)
            logger.debug(f"Cached {key} in skate")
        except Exception as e:
            logger.warning(f"Failed to cache in skate: {e}")

    def get_from_bitwarden(self, key: str) -> Optional[str]:
        """Get value from Bitwarden."""
        if not self.session_key:
            logger.error("Not logged in to Bitwarden")
            return None

        try:
            # Get the full item
            result = subprocess.run([
                "bw", "get", "item", key,
                "--session", self.session_key
            ], capture_output=True, text=True)

            if result.returncode == 0:
                return result.stdout.strip()

            # If direct get fails, try searching
            result = subprocess.run([
                "bw", "list", "items", "--search", key,
                "--session", self.session_key
            ], capture_output=True, text=True, check=True)

            items = json.loads(result.stdout)
            if not items:
                return None

            # Find exact match
            for item in items:
                if item.get("name") == key:
                    return json.dumps(item, indent=2)

            return None

        except Exception as e:
            logger.error(f"Failed to get from Bitwarden: {e}")
            return None

    def get(self, key: str) -> Optional[str]:
        """Get value from cache or Bitwarden."""
        # First check skate cache
        value = self.get_from_skate(key)
        if value:
            logger.debug(f"Found {key} in cache")
            return value

        # If not in cache, check Bitwarden
        logger.debug(f"Checking Bitwarden for {key}")
        value = self.get_from_bitwarden(key)

        if value:
            # Cache for next time
            self.set_in_skate(key, value)
            return value

        return None

    def get_field(self, key: str, field: str) -> Optional[str]:
        """Get specific field from Bitwarden item."""
        # Check cache first
        cache_key = f"{key}:{field}"
        value = self.get_from_skate(cache_key)
        if value:
            logger.debug(f"Found {cache_key} in cache")
            return value

        # Get full item
        item_json = self.get(key)
        if not item_json:
            return None

        try:
            item = json.loads(item_json)

            # Extract specific field based on item type
            if item.get("card") and field in ["number", "expMonth", "expYear", "code", "cardholderName"]:
                value = item["card"].get(field)
            elif item.get("login") and field == "password":
                value = item["login"].get("password")
            elif item.get("login") and field == "username":
                value = item["login"].get("username")
            elif item.get("login") and field == "totp":
                value = item["login"].get("totp")
            elif field == "notes":
                value = item.get("notes")
            elif item.get("fields"):
                for f in item["fields"]:
                    if f.get("name") == field:
                        value = f.get("value")
                        break
                else:
                    value = None
            else:
                # Try to get any top-level field
                value = item.get(field)

            if value:
                self.set_in_skate(cache_key, str(value))
                return str(value)

            return None

        except json.JSONDecodeError:
            logger.error("Failed to parse item JSON")
            return None

# Global instance
bw = BWCookie()

@app.command()
def login():
    """Login to Bitwarden."""
    if bw.login():
        logger.success("Login successful")
        logger.info(f"Export BW_SESSION={bw.session_key}")
    else:
        logger.error("Login failed")
        raise typer.Exit(1)

@app.command()
def unlock():
    """Unlock an already-logged-in Bitwarden vault."""
    session_key = bw.unlock_vault()
    if session_key:
        logger.success("Unlock successful")
        print(f"export BW_SESSION={session_key}")
    else:
        logger.error("Unlock failed")
        raise typer.Exit(1)

@app.command()
def get(key: str, field: Optional[str] = None):
    """Get a secret (returns full JSON). For specific fields: number, expMonth, expYear, code, cardholderName, password, username, notes."""
    if not bw.session_key:
        bw.session_key = os.environ.get("BW_SESSION")
        if not bw.session_key:
            logger.error("Not logged in. Run 'bwcookie login' first.")
            raise typer.Exit(1)

    # Use spinner only if stdout is a TTY (interactive)
    if sys.stdout.isatty():
        with console.status(f"[bold green]Retrieving {key}...", spinner="dots"):
            # Handle field-specific requests
            if field:
                value = bw.get_field(key, field)
            else:
                value = bw.get(key)
    else:
        # Non-interactive mode, no spinner
        if field:
            value = bw.get_field(key, field)
        else:
            value = bw.get(key)

    if value:
        print(value)
    else:
        if field:
            logger.error(f"Field '{field}' not found for key '{key}'")
        else:
            logger.error(f"Key '{key}' not found")
        raise typer.Exit(1)

@app.command()
def value(key: str):
    """Get just the primary value (password for logins, card number for cards, notes for secure notes)."""
    if not bw.session_key:
        bw.session_key = os.environ.get("BW_SESSION")
        if not bw.session_key:
            logger.error("Not logged in. Run 'bwcookie login' first.")
            raise typer.Exit(1)

    # Get full JSON
    json_str = bw.get(key)
    if not json_str:
        logger.error(f"Key '{key}' not found")
        raise typer.Exit(1)

    try:
        item = json.loads(json_str)
        # Extract primary value based on type
        if item.get("login") and item["login"].get("password"):
            print(item["login"]["password"])
        elif item.get("card") and item["card"].get("number"):
            print(item["card"]["number"])
        elif item.get("notes"):
            print(item["notes"])
        elif item.get("fields") and len(item["fields"]) > 0:
            # First field value
            print(item["fields"][0].get("value", ""))
        else:
            logger.error("No primary value found")
            raise typer.Exit(1)
    except json.JSONDecodeError:
        logger.error("Failed to parse item data")
        raise typer.Exit(1)

@app.command()
def clear_cache(key: Optional[str] = None):
    """Clear cached values."""
    if key:
        # Clear specific key
        subprocess.run(["skate", "delete", f"bwcookie:{key}"], check=False)
        # Also clear any field-specific caches
        result = subprocess.run(["skate", "list"], capture_output=True, text=True)
        if result.returncode == 0:
            for line in result.stdout.strip().split('\n'):
                if line.startswith(f"bwcookie:{key}:"):
                    subprocess.run(["skate", "delete", line.split()[0]], check=False)
        logger.success(f"Cleared cache for {key}")
    else:
        # Clear all bwcookie entries
        result = subprocess.run(["skate", "list"], capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip():
            cleared = 0
            for line in result.stdout.strip().split('\n'):
                if line and line.strip():
                    # skate list returns "key value" pairs
                    parts = line.split(None, 1)
                    if parts and parts[0].startswith("bwcookie:"):
                        subprocess.run(["skate", "delete", parts[0]], check=False)
                        cleared += 1
            logger.success(f"Cleared {cleared} cached values")
        else:
            logger.info("No cached values found")

@app.command()
def status():
    """Check status of components."""
    # Check Bitwarden
    with console.status("[bold green]Checking Bitwarden...", spinner="dots"):
        try:
            result = subprocess.run(["bw", "status"], capture_output=True, text=True)
            status = json.loads(result.stdout)
            bw_status = status.get('status', 'unknown')
            console.print(f"✓ Bitwarden: [green]{bw_status}[/green]")
        except:
            console.print("✗ Bitwarden: [red]not available[/red]")

    # Check SSH key
    with console.status("[bold green]Checking SSH key...", spinner="dots"):
        if bw.ssh_key_path.exists():
            console.print(f"✓ SSH key: [green]{bw.ssh_key_path}[/green]")
            # Check public key
            pub_key_path = bw.ssh_key_path.with_suffix(".pub")
            if pub_key_path.exists():
                console.print(f"✓ SSH public key: [green]{pub_key_path}[/green]")
            else:
                console.print("✗ SSH public key: [yellow]not found[/yellow]")
        else:
            console.print("✗ SSH key: [red]not found[/red]")

    # Check skate
    with console.status("[bold green]Checking Skate...", spinner="dots"):
        try:
            result = subprocess.run(["skate", "list"], capture_output=True, check=True)
            # Count bwcookie entries
            entries = 0
            if result.stdout:
                for line in result.stdout.decode().strip().split('\n'):
                    if line and line.strip().startswith("bwcookie:"):
                        entries += 1
            console.print(f"✓ Skate: [green]available[/green] ({entries} cached entries)")
        except:
            console.print("✗ Skate: [red]not available[/red]")

    # Check age
    with console.status("[bold green]Checking age...", spinner="dots"):
        try:
            result = subprocess.run(["age", "--version"], capture_output=True, check=True)
            version = result.stdout.decode().strip()
            console.print(f"✓ Age: [green]{version}[/green]")
        except:
            console.print("✗ Age: [red]not available[/red]")

@app.command()
def list(
    search: Optional[str] = typer.Option(None, "--search", "-s", help="Search query"),
    folder: Optional[str] = typer.Option(None, "--folder", "-f", help="Filter by folder ID"),
    names_only: bool = typer.Option(False, "--names-only", "-n", help="Return only item names")
):
    """List all items in Bitwarden as JSON."""
    if not bw.session_key:
        bw.session_key = os.environ.get("BW_SESSION")
        if not bw.session_key:
            logger.error("Not logged in. Run 'bwcookie login' first.")
            raise typer.Exit(1)

    # Build command
    cmd = ["bw", "list", "items", "--session", bw.session_key]

    if search:
        cmd.extend(["--search", search])

    if folder:
        cmd.extend(["--folderid", folder])

    # Use spinner only if stdout is a TTY (interactive)
    if sys.stdout.isatty():
        with console.status(f"[bold green]Retrieving items from Bitwarden...", spinner="dots"):
            result = subprocess.run(cmd, capture_output=True, text=True)
    else:
        result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        logger.error(f"Failed to list items: {result.stderr}")
        raise typer.Exit(1)

    try:
        items = json.loads(result.stdout)

        if names_only:
            # Extract just the names
            names = [{"name": item.get("name"), "id": item.get("id"), "type": item.get("type")}
                    for item in items]
            print(json.dumps(names, indent=2))
        else:
            # Return full items
            print(json.dumps(items, indent=2))

        # Show count in stderr if interactive
        if sys.stderr.isatty():
            logger.info(f"Found {len(items)} items")

    except json.JSONDecodeError:
        logger.error("Failed to parse Bitwarden response")
        raise typer.Exit(1)

if __name__ == "__main__":
    app()
