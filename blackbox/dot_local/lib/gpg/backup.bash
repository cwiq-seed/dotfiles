# gpg/backup.bash
# shellcheck shell=bash
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::



# :::::::::::::::::::::::::::::::::::::::::::::::::::::::
# backup uid to bitwarden
gpg::backup::bitwarden() {

    local uid="$1"
    local folder_name="$2"

    # Validate uid and folder_name and extract components
    if [[ -z "$uid" || -z "$folder_name" ]]; then
	logger::error "Usage: gpg::backup::bitwarden <uid> <folder_name>"
	return 1
    fi

    # Extract repository from domain part of UID
    local repository
    repository=$(echo "$uid" | sed 's/.*@//')

    # Get full fingerprint and truncate to 16 characters
    local fingerprint
    fingerprint=$(gpg::primary::id "$uid")

    local short_fingerprint
    short_fingerprint="${fingerprint: -16}"

    # Get folder ID (using existing yadm folder)
    local folder_id
    folder_id=$(bitwarden::folder::id "yadm")

    local note_name
    note_name="${short_fingerprint}.${repository}"

    # Modified note creation with error handling
    if ! bitwarden::note::create "$note_name" "$folder_name" "Autogenerated Secure Note. DO NOT EDIT."; then
	logger::error "Failed to create note '$note_name'"
	return 1
    fi

    local public_key_file="/tmp/public.asc"
    local private_key_file="/tmp/private.asc"

    gpg::public::export "$uid" "$public_key_file"
    gpg::private::export "$uid" "$private_key_file"

    # New attachment uploads
    if ! bitwarden::attachment::create "$note_name" "$public_key_file"; then
	logger::error "Failed to upload public key for '$note_name'"
	return 1
    fi

    if ! bitwarden::attachment::create "$note_name" "$private_key_file"; then
	logger::error "Failed to upload private key for '$note_name'"
	return 1
    fi

    # Updated success message
    logger::info "Successfully backed up GPG keys for '$uid' to Bitwarden note '$note_name' with attachments."

    # Add cleanup at end
    shred "$public_key_file" "$private_key_file"
    rm -f "$public_key_file" "$private_key_file"

}
