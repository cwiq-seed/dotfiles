# gpg/backup.bash
# shellcheck shell=bash
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::



# :::::::::::::::::::::::::::::::::::::::::::::::::::::::
# backup uid to bitwarden
gpg::backup::bitwarden() {

    local uid="$1"
    local folder_name="$2"

    # Validate uid and folder_name and extract components
    if [[ -z "$uid" || -z "$folder_name" ]]; then
	logger::error "Usage: gpg::backup::bitwarden <uid> <folder_name>"
	return 1
    fi

    # Extract repository from domain part of UID
    local repository
    repository=$(echo "$uid" | sed 's/.*@//')

    # Get full fingerprint and truncate to 16 characters
    local fingerprint
    fingerprint=$(gpg::primary::id "$uid")
    local short_fingerprint="${fingerprint: -16}"

    # Get folder ID (using existing yadm folder)
    local folder_id
    folder_id=$(bitwarden::folder::id "yadm")

    # Rest of function remains similar but uses derived values
    local public_key_file="/tmp/${short_fingerprint}-public.asc"
    local private_key_file="/tmp/${short_fingerprint}-private.asc"

    gpg --armor --export "$fingerprint" > "$public_key_file"
    gpg --armor --export-secret-keys "$fingerprint" > "$private_key_file"

    local note_name="${short_fingerprint}.${repository}"

    # ... rest of original logic using $note_name ...
    bitwarden::note::create $note_name $folder_name "Autogenerated Secure Note. DO NOT EDIT."

    logger::info "Backed up keys to Bitwarden: $note_name"

}
